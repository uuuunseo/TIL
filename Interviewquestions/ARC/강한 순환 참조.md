# <b> 강한 순환 참조가 발생하는 상황 </b>

클래스 인스턴스 간의 강한 순환 참조  
클로저에서의 강한 순환 참조

<br>

<hr>

<br>

## <b> 클래스 인스턴스 간의 강한 순환 참조 </b>

두 클래스 인스턴스가 서로에 대해 강한 참조를 하고 있을 경우,  
각 인스턴스가 서로를 활성화 상태로 유지하여 강한 순환참조를 발생  

<br>

### <b> 해결방법 </b>
해당 변수는 weak 또는 unowned로 선언해서 강한 순환 참조가 생기는 것을 막을 수 있다.

<br>

<b> 주의 사항 </b>
- <b> weak </b> : 옵셔널 타입으로 선언
- <b> unowned </b>: 인스턴스간 lifttime을 고려

<br>

<hr>

<br>

## <b> 클로저에서의 강한 순환 참조 </b>

<br>

### <b> Context Capture </b>
클로저의 특성 중 하나
사용할 변수 등 클로저가 실행되는 Context를 캡쳐하는데,  
캡쳐가 값을 복사 하는 것이 아닌 <b> Reference Capture를 하게 된다. </b> (해당 변수의 타입에 상관없이)

<br>

클로저 실행  
-> <b> 캡쳐된 Context가 Heap영역에 할당 </b>(reference capture를 했기 때문에 클로저는 클래스를 참조함)  
-> <b> 클래스는 실행을 위해 Heap영역에 할당된 클로저를 참조함</b>

<br>

이렇게 클래스 내부에서 클래스 내부를 참조하는 클로저가 실행되면 강한 순환 참조를 일으킴

<br>

### <b> Define Capture List </b>
<b> [weak self] </b> : self, (클로저가 속한)클래스를 약하게 참조하겠다.  
클로저의 파라미터와 리턴 타입 앞에 캡쳐 목록을 지정 또는 weak, unowned 키워드로 참조 방식을 지정 할 수 있다.

<br>

클로저도 마찬가지로
- <b> weak </b> : 옵셔널 타입으로 nil을 가질 수 있음을 고려
- <b> unowned </b> : 인스턴스간 lifetime을 고려
