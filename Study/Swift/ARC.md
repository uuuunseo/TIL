# <b> ARC </b>

**Automatic Reference Counting**으로 Swift에서 메모리를 관리하고 추적하기 위해 사용한다.

runtime에 계속 실행되는 게 아니라 **compile time**할 때 실행된다.

<br>
<hr>
<br>

## <b> 메모리 관리 방법 </b>

compile time에 자동으로 **retain**과 **release**를 적절한 위치에 삽입하는 방식

해당 인스턴스가 더이상 필요하지 않을 때 클래스의 인스턴스에서 사용하는 메모리를 해지 한다.

<br>
<hr>
<br>

### <b> Heap영역 </b>

Heap영역은 **참조형 자료**들이 머무는 공간이자, 개발자가 동적으로 할당하는 메모리 공간이기 때문에 관리가 필요하기 때문에 Heap영역과 관련이 있다.

Heap영역에 **참조형 자료**들이 얼마나 참조되고 있는 지 카운팅하고 이에따라 메모리를 할당 및 제거를 한다.

이것을 자동으로 해주는 게 바로 **ARC**이다.

<br>
<hr>
<br>
<br>

## <b> 강한 참조 </b>

ARC는 현재 각 클래스 인스턴스를 참조하는 속성, 상수 및 변수의 수(reference Count)를 추적한다.

ARC는 해당 인스턴스에 대한 활성참조가 남아있는 게 하나라도 있다면 인스턴스 할당을 해지하지 않는다.

속성, 상수 또는 변수에 클래스 인스턴스를 할당 할 때마다 해당 속성, 상수 또는 변수는 인스턴스에 대한 강한 참조를 만든다.

참조는 해당 인스턴스를 확고하게 유지하고 해당 강력한 참조가 남아 있는 한 할당 해제를 허용하지 않기 때문에 강한 참조라고 한다.

<br>
<hr>
<br>

### <b> 순환 참조 </b>

인스턴스를 사용하지 않지만 참조가 계속 유지되어서 해제가 안되는 상태가 발생하는 경우

## <b> 약한 참조 </b>

### <b> Weak </b>

weak를 사용해야할 때 주의해야할 점  

weak으로 선언한 변수는 참조하는 동안 해당 인스턴스가 할당 해제 될 수 있다.  

Reference Count를 증가시키지 않기 때문에 다른 곳에서 강한 참조가 없어지게 돼서 referenceCount가 0이 되면 ARC가 인스턴스를 할당 해제 시키기 때문이다.  

할당 해제 될 때 ARC는 weak로 선언된 변수에다가 자동으로 nil을 할당한다. -> Optional 변수로 선언해야 한다.

<br>
<hr>
<br>

### <b> Unowned </b>

weak처럼 unowned도 참조하는 인스턴스를 강하게 유지하지 않는다.
weak와 차이점은 unowned로 참조하는 인스턴스는 항상 값이 존재해야 한다.
ARC가 참조하는 인스턴스를 할당 해제 해도 nil을 할당하지 않는다.

<br>
<hr>
<br>

## <b> 클로저의 순환 참조 </b>

클래스의 인스턴스의 속성에 Closure를 할당하고 해당 Closure에서 인스턴스를 캡처하는 경우에도 강한 순환 참조가 일어나게 된다.

<br>
<hr>
<br>

### <b> 왜?? </b>

클로저는 참조 타입이다. 
class의 프로퍼티로 클로저를 선언하면 해당 클로저에 대한 강한 참조가 생기게 된다. 

클로저에서 인스턴스를 접근하게 되면 해당 인스턴스를 캡쳐하게 된다. 

이 때 캡쳐를 강한 참조로 하기 때문에 클로저와 인스터스 간의 강한 순환 참조가 발생하게 된다.