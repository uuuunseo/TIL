# <b> Strong, weak, unowned</b>
메모리를 참조하는 방법  

<br>

## <b> Strong (강한참조) </b>
- 해당 인스턴스의 소유권을 가진다.
- 자신이 참조하는 인스턴스의 retain count를 증가시킨다.
- 선언할 때 지정해주지 않으면 default 값으로 Strong이 지정된다.  

<b> 서로 객체를 소유하려는 특성 때문에 순환참조가 발생하여 메모리 누수를 발생시킬 수 있다. </b>

<br>

<hr>

<br>

## <b> weak (약한 참조) </b>
- 해당 인스턴스의 소유권을 가지지 않는다. (주소값만을 가짐)
- 자신이 참조하는 인스턴스의 retain count를 증가시키지 않는다. (release도 발행하지 않음)
- 자신이 참조는 하지만 weak 메모리를 해제 시킬 수 있는 권한은 다른 클래스에 있다.
- 메모리가 해제될 때 <b> 자동으로 nil로 초기화 해준다. </b>
- weak 속성을 사용하는 객체는 <b> 항상 optional타입이어야 한다. </b> (해당 객체가 nil이 될 수 도 있기 때문!!)

<br>

<hr>

<br>

## <b> unowned (미소유참조) </b>
- 해당 인스턴스의 소유권을 가지지 않는다.
- 자신이 참조하는 인스턴스의 retain count를 증가시키지 않는다.
- nil이 될 수 없다. (optional 불가능)

<br>

### <b> weak와 unowned의 차이점 </b>
- <b> weak </b> : 객체를 계속해서 추적하면서 객체가 사라지면 nil로 바뀐다.
- <b> unowned </b> : 객체가 사라지게 되면 댕글링 포인터가 남는다. -> 댕글링 포인터를 참조하면 crash가 발생
- unowned는 사라지지 않을거라고 보장되는 객체에만 설정해야 한다.

<br>

> <b> 댕글링 포인터 </b> : 원래 바라보던 객체가 해제되면서 할당되지 않는 공간을 바라보는 포인터

<br>

<hr>

<br>

## <b> 그렇다면 어느 상황에 쓰일까? </b>

<br>

### <b> strong </b>
레퍼런스 카운트를 증가시켜서 ARC로 인한 메모리 해제를 피하고, 객체를 안전하게 사용하고자 할 때 사용

<br>

### <b> weak </b>
대표적으로 retain cycle에 의해 메모리가 누수되는 문제를 막기 위해 사용되며, delegate패턴이 있다.

<br>

### <b> unowned </b>
객체의 라이프사이클이 명확하고 개발자에 의해 제어 가능이 명확한 경우, weak Optional타입 대신 사용하여 좀 더 간결한 코딩이 가능하다. 

<br>

<b> 약한 참조가 필요한 경우 weak만을 사용하고, guard let (또는 if let) 구문을 통해 안전하게 옵셔널 추출을 권장 </b>
