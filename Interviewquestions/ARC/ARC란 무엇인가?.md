# <b> ARC란 무엇인가? </b>


# <b> ARC </b>
Auto Reference Counting  
메모리 영역중 힙 영역을 관리하면서 힙에 할당된 인스턴스의 메모리를 알아서 관리해준다.

</br>

# <b> 메모리 관리 방법 </b>
메모리의 참조 횟수를 계산하여, 참조 횟수가 0이 되면 더이상 사용하지 않는 메모리로 판단하여 해제시킨다.  
따라서 모든 인스턴스는 자신의 RC값을 가지고 있다.  
</br> 

## <b> 참조 횟수 +1 </b>
- 참조 횟수가 1회 증가되는 순간 = <b>인스턴스의 주소값을 변수에 할당할 때</b>  
</br>
- <b> 인스턴스를 새로 생성할 때 </b>
  - 인스턴스를 새로 생성할 때 (새로운 변수에 대입할 때) 해당 인스턴스에 대한 RC값 증가  
</br>
- <b> 기존 인스턴스를 다른 변수에 대입할 때 </b>
  - 당연히 참조에 의하기 때문에 RC값이 증가  
</br>

## <b> 참조 횟수 -1 </b>
- <b> 인스턴스를 가리키던 변수가 메모리에서 해제되었을 때 </b>
  - 인스턴스를 참조하고 있던 변수가 메모리에서 해제 되었을 때 해당 인스턴스의 RC값이 감소  
</br>

- <b> nil이 지정되었을 때 </b>
  - 해당 인스턴스를 가리키던 변수가 옵셔널 타입일 때 nil값을 가지게 되면 RC값이 감소  
</br>  

- <b> 변수에 다른 값을 대입한 경우 </b>
  - 변수에 저장된 주소값이 바뀌어서 RC값이 감소한다.  
</br>

- <b> 프로퍼티의 경우, 속해 있는 클래스 인스턴스가 메모리에서 해제될 때 </b>
  - 클래스 안에 클래스 인스턴스가 프로퍼티로 존재할 때 클래스 인스턴스를 생성하면 인스턴스도 같이 생성되면서 두 인스턴스 각각 RC가 증가된다.  
</br>
  - 클래스 인스턴스가 메모리에서 해제될 경우 인스턴스의 RC가 하나 감소한다.  
</br>
  -  클래스 인스턴스가 메모리에서 해제된다고 해서, 프로퍼티 인스턴스의 메모리가 같이 해제되는 것이 아니라 RC가 감소하는 것이다.  

</br>

# <b> 강한 참조 </b>

<b> 인스턴스의 주소값이 변수에 할당할 때 RC값이 증가하는 것 </b>  
ARC의 기본 값이 강한참조 인 것!  
</br>  

# <b> 순환 참조 </b>
<b> 두 개의 객체가 서로가 서로를 참조하고 있는 형태 </b>  

ARC의 단점 </br>
순환 참조 발생 시 영구적으로 메모리가 해제되지 않을 수도 있다.  
</br>  

## <b> 순환 참조의 문제점 </b>

서로 참조하고 있던 두 개의 객체에 nil을 대입한 순간, 각각 가르키던 인스턴스의 값을 1 감소 시켰지만. </br>
힙에 있는 인스턴스의 RC값은 0이 아니라 1이게 된다.  
</br>  

## <b> 왜? </b>
순환 참조 때문에 각각 인스턴스의 RC값이 1증가했기 때문이다.  
</br>

## <b> 문제점 </b>
<b> 서로가 서로를 참조하고 있어서 RC값이 0이 되지 못한다는 것! </br> </b>
- 심지어 해당 인스턴스를 가리키던 변수들도 nil로 지정됐기 때문에  
접근할 수 있는 방법이 없어서 메모리 해제도 할 수 없게 된다.  
</br>  
- 이렇게 strong을 사용해서 순환참조에 문제가 생긴 경우를
<b> 강한 순환 참조</b>라고 한다.

</br>

# <b> weak, unowned </b>
강한 순환 참조를 해결하기 위해 사용한다.

</br>

## <b> weak (약한참조) </b>
인스턴스를 참조할 시, RC를 증가시키지 않는다.  
참조하던 인스턴스가 메모리에서 해제된 경우, 자동으로 nil이 할당되어 메모리가 해제된다.  

</br>

<b> weak은 무조건 옵셔널타입 변수여야 한다. </b>

순환 참조이지만 weak으로 선언되어 RC값을 올리지 않는 것은 <b> 약한 순환 참조</b>라고 한다.  
강한 순환 참조가 난 경우, <b> 둘 중에 수명이 더 짧은 인스턴스를 가리키는 애를 약한 참조로 선언</b>

</br>

## <b> unowed (미소유 참조) </b>
weak와 동일하게 인스턴스를 참조할 시, RC를 증가시키지 않는다.  
unowed는 인스턴스를 참조하는 도중에 해당 인스턴스가 메모리에서 사라질 일이 없다고 확신해야한다.
</br>
- 참조하던 인스턴스가 만약 메모리에서 해제된 경우, nil을 할당받지 못하고 해제된 메모리 주소값을 계속 들고 있는 것 -> 위험하다!  
  </br>
- unowed으로 선언된 변수가 가리키던 인스턴스가 메모리에서 먼저 해제된 경우, 접근하려 하면 에러를 발생시킨다.  
  </br>
- 전체적인 동작은 weak와 똑같으나 unowed가 붙은 a인스턴스가 가리키는 다른 인스턴스 b는, a 인스턴스가 해제되기 전까지 절대 먼저 해체되어서는 안된다.  
  </br> 
- weak와 반대로 둘 중에 수명이 더 긴 인스턴스를 가리키는 애를 미소유 참조로 선언한다.

</br>

<b> 만약 먼저 해체 된다면? </b>    
- weak의 경우 nil로 값을 할당받지만  
unowed의 경우 nil을 할당받지 못해 이미 해제된 메모리의 주소값을 들고 있게 된다.  
</br>
- 접근하려고 하면 이미 메모리에서 해제된 포인터 값에 접근하려 해서 에러가 발생한다.

</br>

### <b> unowed는 에러를 발생시킬 위험이 있어서 weak를 사용하는 것을 권장한다.</b>